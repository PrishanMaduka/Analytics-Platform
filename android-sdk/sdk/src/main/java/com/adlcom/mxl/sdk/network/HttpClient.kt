package com.adlcom.mxl.sdk.network

import android.content.Context
import com.adlcom.mxl.sdk.config.SdkConfiguration
import com.adlcom.mxl.sdk.network.NetworkMonitorInterceptor
import okhttp3.CertificatePinner
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.logging.HttpLoggingInterceptor
import java.util.concurrent.TimeUnit

/**
 * HTTP client for communicating with MxL backend.
 * Supports TLS 1.2+, certificate pinning, and retry logic.
 */
class HttpClient private constructor(
    private val okHttpClient: OkHttpClient,
    private val baseUrl: String,
    private val apiKey: String
) {
    companion object {
        fun create(context: Context, configuration: SdkConfiguration): HttpClient {
            val clientBuilder = OkHttpClient.Builder()
                .connectTimeout(30, TimeUnit.SECONDS)
                .readTimeout(30, TimeUnit.SECONDS)
                .writeTimeout(30, TimeUnit.SECONDS)
                .retryOnConnectionFailure(true)
            
            // Certificate pinning
            if (configuration.enableCertificatePinning && configuration.certificatePins.isNotEmpty()) {
                val pinnerBuilder = CertificatePinner.Builder()
                configuration.certificatePins.forEach { pin ->
                    pinnerBuilder.add(configuration.endpoint, pin)
                }
                clientBuilder.certificatePinner(pinnerBuilder.build())
            }
            
            // Logging interceptor (only in debug builds)
            // Note: BuildConfig will be generated by Android build system
            try {
                val buildConfigClass = Class.forName("com.adlcom.mxl.sdk.BuildConfig")
                val debugField = buildConfigClass.getField("DEBUG")
                val isDebug = debugField.getBoolean(null) as Boolean
                if (isDebug) {
                    val loggingInterceptor = HttpLoggingInterceptor().apply {
                        level = HttpLoggingInterceptor.Level.BODY
                    }
                    clientBuilder.addInterceptor(loggingInterceptor)
                }
            } catch (e: Exception) {
                // BuildConfig not available, skip logging
            }
            
            // Add network monitoring interceptor
            if (configuration.enableNetworkMonitoring) {
                clientBuilder.addInterceptor(NetworkMonitorInterceptor(configuration))
            }
            
            // Add API key interceptor
            clientBuilder.addInterceptor { chain ->
                val original = chain.request()
                val requestBuilder = original.newBuilder()
                    .header("Authorization", "Bearer $apiKey")
                    .header("Content-Type", "application/json")
                    .header("User-Agent", "MxL-Android-SDK/1.0.0")
                
                chain.proceed(requestBuilder.build())
            }
            
            return HttpClient(
                okHttpClient = clientBuilder.build(),
                baseUrl = configuration.endpoint,
                apiKey = configuration.apiKey
            )
        }
    }
    
    suspend fun post(path: String, body: String): NetworkResult {
        return try {
            val requestBody = RequestBody.create(
                "application/json".toMediaType(),
                body
            )
            
            val request = Request.Builder()
                .url("$baseUrl$path")
                .post(requestBody)
                .build()
            
            val response = okHttpClient.newCall(request).execute()
            
            if (response.isSuccessful) {
                NetworkResult.Success(response.body?.string() ?: "")
            } else {
                NetworkResult.Error(
                    code = response.code,
                    message = response.message
                )
            }
        } catch (e: Exception) {
            NetworkResult.Error(
                code = -1,
                message = e.message ?: "Unknown error"
            )
        }
    }
}

sealed class NetworkResult {
    data class Success(val data: String) : NetworkResult()
    data class Error(val code: Int, val message: String) : NetworkResult()
}

